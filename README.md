魚の世話シミュレーションゲーム

このプロジェクトは、ユーザーが魚の飼い主として仮想の魚と対話するシンプルなシミュレーションゲームです。ゲームの目標は、魚が生き続け健康でいるように、魚に餌をあげたり、無視したり、泳がせたりすることです。ユーザーは魚の状態を確認したり、状態（空腹、体重）を変更したり、自分の行動の結果を体験できます。

特徴：

魚に餌を与える：魚は食べて成長し、満足し、体重が増えます。
魚を無視する：餌を与えないと魚は体重が減り、最終的には無視により死んでしまうことがあります。
泳ぐ：魚が優雅に泳ぐ様子を見ます。
魚の詳細表示：魚の名前、色、現在の体重などを表示します。
ゲーム終了：魚が無視により死んだ場合、またはプレイヤーが終了を選んだ場合にゲームが終了します。
直面した問題：

魚の体重の管理：主要な課題は、魚の体重、空腹状態、および魚と飼い主とのインタラクションの管理でした。最初は、魚に餌を与えたり無視したりしたときに体重が適切に変化するようにすることに難しさを感じていました。また、魚が「満腹すぎる」または「空腹すぎる」ときの挙動をどう扱うかが問題でした。

解決策：魚クラスにweight属性を使用して魚の体重を追跡しました。eat()メソッドでは、餌を与えることで魚が10グラム増えます。体重が100グラムを超えると魚は空腹になります。loseWeight()メソッドでは、無視された場合に魚は1日で5グラム減ります。

魚の空腹状態の管理：もう一つの課題は、魚の空腹状態をどう扱うかでした。餌を与えた後、魚はすぐに餌を求めるべきではなく、ある程度体重が増えた後に空腹になるべきです。

解決策：isHungryというboolean変数を使用して、魚が空腹かどうかを追跡しました。体重が特定の閾値を超えると空腹状態に更新され、条件を追加して空腹の場合に餌を求める挙動を管理しました。

ユーザーインタラクション：最初は、ユーザー入力の流れを管理し、魚が死んだり、プレイヤーが終了を選んだときにゲームが途切れずに続くようにすることに課題がありました。

解決策：ユーザーが異なるアクションを選択できるループを作成し、各アクション後に魚が死んでいないか確認するチェックを加えました。もし魚が死んで（体重 ≤ 0）、ゲームが自動的に終了し、プレイヤーに魚の死を知らせるようにしました。

複数のアクションの管理：餌を与える、無視する、泳がせるなど、複数のアクションとその反応を一貫性を持って実装することが難しかったです。

解決策：ゲームロジックをFishControllerクラスのメソッドに分割し、魚とのインタラクションを管理しました。これによりプログラムがモジュール化され、整理されて読みやすくなりました。各アクション（餌を与える、無視するなど）は、それぞれのメソッドに実装し、コードを整理しました。

動作方法：

魚クラス：魚の名前、色、体重、空腹状態などの属性を持ち、魚の行動（食べる、体重を減らす、餌を求める、泳ぐなど）を定義します。
FishControllerクラス：魚の飼い主のインタラクション（餌を与える、無視するなど）を管理し、ゲームループとユーザー入力を処理します。
プレイ方法：

プレイヤーは魚の飼い主として名前を入力します。
魚の初期情報（名前、色、体重）が表示されます。
プレイヤーは次のアクションを選択できます：
魚に餌を与えて成長させる。
魚を無視して体重が減るのを見守る。
魚を泳がせて楽しませる。
魚の詳細を表示する。
魚の体重が0になった場合、ゲームが終了し、魚が無視によって死んだことが通知されます。
プレイヤーはいつでも終了を選ぶことができます。
学んだこと：

このプロジェクトを通じて、現実の行動をプログラミング環境でシミュレートする方法を学びました。オブジェクトの状態管理、ユーザー入力の処理、基本的なシミュレーションの実装についての経験を得ました。
オブジェクト指向設計の重要性を学び、クラス間で責任を分割してコードを整理し、保守性を高める方法を理解しました。
